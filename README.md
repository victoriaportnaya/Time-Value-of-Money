# Фінансова математика в Python

### Навіщо це все треба, є ж Excel?

Так, Excel дійсно є, і часто використовувати саме його для фінансових обчислень може бути простіше. Але не забувайте Ваші **hard skills** і **CV**. Рядок "Фінансовий аналіз у Python" виглядає явно краще, ніж "фінансовий аналіз в Excel" для вашого потенційного роботодавця, погодьтеся? Ба більше, вміння використовувати Python для найрізноманітніших завдань загалом робить вас більш конкурентоспроможним аналітиком, здатним справлятися зі складнішими завданнями.


### Імпорт бібліотеки

Для того, щоб почати роботи з потрібними нам функціями, спочатку потрібно імпортувати дві *бібліотеки*: **Numpy** (загалом, вона використовується для математичних операцій з матрицями) та її спеціально розроблену для фінансових застосувань підбібліотеку: **numpy_financial**.
<br>
<br>
**Зауваження!** Оскільки потрібна нам бібліотека не є "базовою", перед імпортом потрібно використовувати pip (завантажити її).


```python
pip install numpy-financial
```

    Requirement already satisfied: numpy-financial in c:\users\victo\anaconda3\lib\site-packages (1.0.0)
    Requirement already satisfied: numpy>=1.15 in c:\users\victo\anaconda3\lib\site-packages (from numpy-financial) (1.24.3)
    Note: you may need to restart the kernel to use updated packages.
    


```python
import numpy as np 
import numpy_financial as npf 
```

### Процентна ставка 

Припустимо, що ми маємо такі дані про кількість періодів, періодичний платіж, PV і FV. На основі них ми хочемо розрахувати **процентну ставку**.


```python
periods = 12
payment = 1500
pv = 500
fv = 300
```

Для розрахунку ефективної процентної ставки ми використовуємо функцію **npf.rate()**. Як **обов'язкові** аргументи вводимо: 
1. **nper** - кількість періодів (scalar або array)
2. **pmt** - виплата (scalar або array)
3. **pv** - present value (scalar або array)
4. **fv** - future value (scalar або array)
І *опціональні* аргументи, які можуть стати в пригоді:
5*) *when*: коли відбувається оплата - наприкінці періоду (0) або на початку (1).


```python
rate = npf.rate(periods, payment, pv, fv)
print(rate)
```

    -2.1436255592964812
    

### Internal Return Rate (IRR)

Тепер нехай у нас є така інформація: початкова інвестиція (яку ми записуємо зі знаком "-"), і грошовий потік у форматі. Записуємо їх в list [ ]. Наше завдання - розрахувати **IRR**.


```python
initial_investment = -10000
cash_flow = [initial_investment, 1500, 2500, 3000, 5000, 4000, -1000, -2000, 3500]
```

Для розрахунку IRR ми будемо використовувати функцію **np.irr()**. Як єдиний аргумент - *cash flow*.


```python
irr = npf.irr(cash_flow)
print(irr) # формат float, тобто щоб отримати %, можна помножити на 100
```

    0.14913720237912864
    

### Приведення вартості: Present Value & Future Value

#### Present Value

Для розрахунку PV (present value) використовуємо функцію **npv.pv()**. На вхід вона приймає **обов'язкові** аргументи:
1. **rate** - процентна ставка на **період** (array / scalar)
2. **nper** - кількість періодів (array / scalar)
3. **pmt** - регулярний платіж (array / scalar)
І *опціональні* аргументи: 
4*) *fv* - future value (array / scalar)
5*) *when* - на який момент платіж (початок періоду - 1, кінець - 0).

<br> **Зауваження!** Якщо далі платежі не здійснюються і знаємо тільки FV, то записуємо pmt = 0 і далі вносимо аргумент fv.

**Розглянемо приклад**
<br>
Яка PV (наприклад, початкова інвестиція) інвестиції, яка повинна скласти 350000 грн. після 10 років заощаджень по 2000 грн щомісяця?
<br> Припустимо, що відсоткова ставка становить 5% (річних) з щомісячним нарахуванням.
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.05 # не забуваємо про формат float! розділимо далі на 12, щоб отримати rate per period
nper = 10 # оскільки платежі щомісячні, далі помножимо на 12, щоб отримати потрібну кількість періодів
pmt = -200 
fv = 350000 

pv = npf.pv(rate/12, nper*12, pmt, fv)
print(pv)
```

    -193650.09403901073
    

#### Future Value

Майже аналогічно, для розрахунку FV (future value) використовуємо функцію **npv.fv()**. На вхід вона приймає **обов'язкові** аргументи:
1. **rate** - процентна ставка на **період** (array / scalar)
2. **nper** - кількість періодів (array / scalar)
3. **pmt** - регулярний платіж (array / scalar)
4) **pv** - present value (array / scalar) **тут Present Value - обов'язковий аргумент!**
<br> <br>**Зауваження!** Якщо далі платежі не здійснюються, тільки початковий платіж (PV), то pmt = 0.


**Розглянемо приклад**
<br> Якою буде FV через 10 років, якщо заощаджувати 5000 грн. зараз і додатково відкладати по 150 грн. щомісяця. 
<br> Припустимо, що відсоткова ставка становить 6% (річних) з щомісячним нарахуванням?
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.06 # не забуваємо про формат float! розділимо далі на 12, щоб отримати rate per period
nper = 10 # оскільки платежі щомісячні, далі помножимо на 12, щоб отримати потрібну кількість періодів
pmt = -150 
pv = 5000 

fv = npf.fv(rate/12, nper*12, pmt, pv)
print(fv)
```

    15484.918350807255
    

### Чиста поточна вартість: Net Present Value

Тут усе дуже просто. Як нескладно здогадатися, ми використовуємо функцію **npf.npv()**. Є тільки два аргументи: 
1. **rate** - ставка дисконтування
2. **values** - грошовий потік у форматі list [ ].


**Розглянемо приклад**
<br> Проаналізуємо потенційний проект з початковою інвестицією 100 000 грн. і прогнозованими грошовими потоками 50 000, 8 000, 15000 і 60 000 в кінці кожного періоду, дисконтованими за ставкою 7% за період. Знайти NPV.
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.07
cash_flow = [-100000, 50000, 8000, 15000, 60000]

npv = npf.npv(rate, cash_flow)
print(npv)
```

    11734.662665016804
    

### Ануїтетний платіж

Для того, щоб розрахувати суму платежу, ми можемо скористатися функцією **npf.pmt()**. На вхід вона приймає такі **обов'язкові** аргументи: 
1. **rate** - процентна ставка
2. **nper** - кількість періодів 
3. **pv** - present value 
4. **when** - коли сплачується (наприкінці періоду - 0, на початку - 1).
<br> Опціональний аргумент один - *future value*.

**Розглянемо приклад**
<br> Який щомісячний платіж необхідний для погашення кредиту в розмірі 1 000 000 грн. за 15 років при річній процентній ставці 7%?
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.07
nper = 15
pv = 1000000
```


```python
payment_end = npf.pmt(rate/12, nper*12, pv, 0) # when = 0 (наприкінці періоду)
print(payment_end)
```

    -8988.28270852425
    

### Кількість періодів для досягнення конкретної Future Value

Тепер припустимо, що є певна сума, яку ви хочете досягти або виплатити (наприклад, назбирати на пенсію або виплатити борг). Для того, щоб розрахувати необхідну кількість виплат (тобто періодів), ми можемо скористатися функцією **npf.nper()**.
<br> На вхід вона приймає наступні **обов'язкові** аргументи: 
1. **rate** - процентна ставка
2. **pmt** - сума регулярного платежу
3. **pv** - present value 


**Розглянемо приклад**
<br> Якщо ви сплачуватимете лише 500 грн. щомісяця, скільки часу знадобиться для погашення кредиту в розмірі 15 000 грн. під 7% річних?
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.07
pmt = -500 # так як платимо, то знак "-"
pv = 15000

periods = npf.nper(rate/12, pmt, pv)
print(periods) 
```

    33.074131443519015
    

### Principal & Interest 

Як ви знаєте, здійснюючи платіж за борг, ви сплачуєте дві частини: за сам борг (*principal*) і проценти (*interest*). У кожен наступний період їхні пропорції одна відносно одної різні. За допомогою функцій нашої бібліотеки можна розрахувати кожну з частин у кожен момент виплати, а також візуалізувати пропорції.

### Principal  

Для розрахунку частини principal - тобто тіла кредиту - нам знадобиться функція **npf.ppmt()**. На вхід вона приймає такі **обов'язкові** аргументи: 
1. **rate** - процентна ставка
2. **per** - номер періоду, який ми розглядаємо
3. **nper** - кількість періодів
4. **pv** - present value
<br> Як *опціональний* аргумент можна вказати *fv (future value)* та *when* - коли сплачується (наприкінці періоду - 0, на початку - 1).

**Розглянемо приклад**
<br> Який щомісячний платіж необхідний для погашення кредиту в розмірі 100 000 грн. за 10 років при річній процентній ставці 5%? Знайдіть основний платіж у перший місяць. 
<br> **Перепишемо дані у вигляді аргументів і скористаємося функцією.**


```python
rate = 0.05
per = 1
nper = 10
pv = 100000

principal = npf.ppmt(rate/12, per, nper*12, pv)
print(principal)
```

    -643.9884857240886
    

### Interest  

Частина боргу в рахунок відсотків розраховується схожим чином, тільки тепер із функцією **npf.ipmt()**. Усі обов'язкові та опціональні **аргументи залишаються тими ж самими**, що і в розрахунку principal - частини.

**Розглянемо той самий приклад та порівняємо**.


```python
interest = npf.ipmt(rate/12, per, nper*12, pv)
print(interest)
```

    -416.6666666666667
    

### Графік виплат за боргом та візуалізація

Ми можемо **візуалізувати** оплату боргу, щоб побачити, як змінюється пропорція principal і interest частин протягом періодів. Аналогічно, ми можемо створити **графік виплат** і побачити, коли і скільки в яку частину платимо.


#### Продовжуємо розглядати все той же попередній приклад

Для початку *імпортуємо* ще дві бібліотеки: **Pandas** - для роботи з таблицями - і **Matplotlib**, яка потрібна для візуалізації.


```python
import pandas as pd 
import matplotlib.pyplot as plt
```

Знайдемо **загальний щомісячний платіж** (тобто principal + interest).


```python
rate = rate/12
nper = nper*12
monthly_payment = -npf.pmt(rate, nper, pv)
```

Тепер **створимо порожні lists**, які нам знадобляться для створення графіка виплат і його візуалізації. У них ми будемо класти відповідні елементи для кожного з періодів (скільки платимо за кожною з частин).
<br>Також скажемо, що в нас є **баланс**, який показує, **скільки потрібно виплатити**. Спочатку він дорівнює самій сумі боргу, тобто pv.


```python
balance = pv

principal_paid = []
interest_paid = []
total_payments = []
```

Тепер пройдемося циклом по кожному з періодів і будемо крок за кроком класти потрібну частину виплати у відповідний список.
<br>
<br> **Зверніть увагу**, що principal ми рахуємо саме від тіла боргу, а не від відсотка, тому від PV поступово віднімаємо саме principal_payment, а не загальний платіж.


```python
for period in range(1, nper + 1): 
    principal_payment = npf.ppmt(rate, period, nper, balance)
    interest_payment = npf.ipmt(rate, period, nper, balance)
    balance += principal_payment
    
    principal_paid.append(principal_payment)
    interest_paid.append(interest_payment)
    total_payments.append(monthly_payment)
```

Тепер перетворюємо наші списки на датафрейм (таблицю): для цього спочатку покладемо їх в словник, а потім застосуємо pd.DataFrame.


```python
payments = {'Місяць': np.arange(1, nper +1), 
            'Principal': principal_paid, 
            'Interest': interest_paid, 
            'Total payment': total_payments}

schedule = pd.DataFrame(payments)
print(schedule)
```

           Місяць  Principal                 Interest  Total payment
    0           1  -4.460424      -2.8935185185185186       7.353942
    1           2  -4.460354       -2.893260397905176       7.353942
    2           3  -4.460284      -2.8930022870935135       7.353942
    3           4  -4.460214       -2.892744186083786       7.353942
    4           5  -4.460144        -2.89248609487625       7.353942
    ...       ...        ...                      ...            ...
    17275   17276  -2.705888  -0.00039149944915485086       7.353942
    17276   17277  -2.705767  -0.00031318106092065274       7.353942
    17277   17278  -2.705646  -0.00023487192222399213       7.353942
    17278   17279  -2.705526  -0.00015657203272907182       7.353942
    17279   17280  -2.705405   -7.828139209967352e-05       7.353942
    
    [17280 rows x 4 columns]
    

Нарешті, візуалізуємо виплати. Дізнатися, як саме малюється графік, можна в документації *Matplotlib*. Також є альтернативна бібліотека для візуалізації - *seaborn* - яка часто дає змогу малювати більш естетичні графіки.


```python
fig, ax = plt.subplots(figsize=(10, 6))

ax.bar(schedule['Місяць'], principal_paid, label='Principal', color='blue', alpha=0.7)
ax.bar(schedule['Місяць'], interest_paid, bottom=principal_paid, label='Interest', color='orange', alpha=0.7)

ax.set_xlabel('Місяць')
ax.set_ylabel('Сума')
ax.set_title('Графік виплат по боргу')
ax.legend()

plt.show()
```
